# Unit type definition
type Unit {
  id: ID!
  accountId: String!
  suggestedVin: String!
  errorCode: String
  possibleValues: String
  errorText: String
  vehicleDescriptor: String
  make: String!
  manufacturerName: String!
  model: String!
  modelYear: String!
  series: String!
  vehicleType: String!
  bodyClass: String
  doors: String
  grossVehicleWeightRatingFrom: String
  grossVehicleWeightRatingTo: String
  wheelBaseInchesFrom: String
  bedType: String
  cabType: String
  trailerTypeConnection: String
  trailerBodyType: String
  customMotorcycleType: String
  motorcycleSuspensionType: String
  motorcycleChassisType: String
  busFloorConfigurationType: String
  busType: String
  engineNumberOfCylinders: String
  displacementCc: String
  displacementCi: String
  displacementL: String
  engineBrakeHpFrom: String
  fuelTypePrimary: String
  seatBeltType: String
  otherRestraintSystemInfo: String
  frontAirBagLocations: String
  createdAt: AWSTimestamp!
  updatedAt: AWSTimestamp!
  deletedAt: AWSTimestamp
}

# Input types
input CreateUnitInput {
  accountId: String!
  suggestedVin: String!
  make: String!
  manufacturerName: String!
  model: String!
  modelYear: String!
  series: String!
  vehicleType: String!
  errorCode: String
  possibleValues: String
  errorText: String
  vehicleDescriptor: String
  bodyClass: String
  doors: String
  grossVehicleWeightRatingFrom: String
  grossVehicleWeightRatingTo: String
  wheelBaseInchesFrom: String
  bedType: String
  cabType: String
  trailerTypeConnection: String
  trailerBodyType: String
  customMotorcycleType: String
  motorcycleSuspensionType: String
  motorcycleChassisType: String
  busFloorConfigurationType: String
  busType: String
  engineNumberOfCylinders: String
  displacementCc: String
  displacementCi: String
  displacementL: String
  engineBrakeHpFrom: String
  fuelTypePrimary: String
  seatBeltType: String
  otherRestraintSystemInfo: String
  frontAirBagLocations: String
}

input UpdateUnitInput {
  id: ID!
  accountId: String!
  suggestedVin: String
  make: String
  manufacturerName: String
  model: String
  modelYear: String
  series: String
  vehicleType: String
  errorCode: String
  possibleValues: String
  errorText: String
  vehicleDescriptor: String
  bodyClass: String
  doors: String
  grossVehicleWeightRatingFrom: String
  grossVehicleWeightRatingTo: String
  wheelBaseInchesFrom: String
  bedType: String
  cabType: String
  trailerTypeConnection: String
  trailerBodyType: String
  customMotorcycleType: String
  motorcycleSuspensionType: String
  motorcycleChassisType: String
  busFloorConfigurationType: String
  busType: String
  engineNumberOfCylinders: String
  displacementCc: String
  displacementCi: String
  displacementL: String
  engineBrakeHpFrom: String
  fuelTypePrimary: String
  seatBeltType: String
  otherRestraintSystemInfo: String
  frontAirBagLocations: String
}

input ListUnitsInput {
  accountId: String!
  limit: Int
  nextToken: String
}

type ListUnitsResponse {
  items: [Unit!]!
  count: Int!
  nextToken: String
}

# Existing AuthenticatedResponse type
type AuthenticatedResponse {
  message: String!
  timestamp: String!
  user: String
  success: Boolean!
}

# Location Types
enum LocationType {
  address
  coordinates
}

# Address Type
type Address {
  streetAddress: String!
  streetAddress2: String
  city: String!
  stateProvince: String
  postalCode: String!
  country: String!
}

# Coordinates Type
type Coordinates {
  latitude: Float!
  longitude: Float!
  altitude: Float
  accuracy: Float
}

# Location Interface
interface Location {
  accountId: String!
  locationType: LocationType!
  extendedAttributes: AWSJSON
}

# Concrete Location Types
type AddressLocation implements Location {
  accountId: String!
  locationType: LocationType!
  extendedAttributes: AWSJSON
  address: Address!
}

type CoordinatesLocation implements Location {
  accountId: String!
  locationType: LocationType!
  extendedAttributes: AWSJSON
  coordinates: Coordinates!
}

# Union Type for Location Results
union LocationResult = AddressLocation | CoordinatesLocation

# Location Input Types
input AddressInput {
  streetAddress: String!
  streetAddress2: String
  city: String!
  stateProvince: String
  postalCode: String!
  country: String!
}

input CoordinatesInput {
  latitude: Float!
  longitude: Float!
  altitude: Float
  accuracy: Float
}

input CreateAddressLocationInput {
  accountId: String!
  address: AddressInput!
  extendedAttributes: AWSJSON
}

input CreateCoordinatesLocationInput {
  accountId: String!
  coordinates: CoordinatesInput!
  extendedAttributes: AWSJSON
}

input UpdateAddressLocationInput {
  accountId: String!
  address: AddressInput!
  extendedAttributes: AWSJSON
}

input UpdateCoordinatesLocationInput {
  accountId: String!
  coordinates: CoordinatesInput!
  extendedAttributes: AWSJSON
}

# Location List Result Type
type LocationListResult {
  locations: [LocationResult!]!
  nextCursor: String
}

# Location List Options Input
input ListLocationsInput {
  limit: Int
  cursor: String
}

# Query and Mutation definitions
type Query {
  # Existing query
  validateAuthn: AuthenticatedResponse
  
  # Unit queries
  getUnit(id: ID!, accountId: String!): Unit
  listUnits(input: ListUnitsInput!): ListUnitsResponse!
  
  # Location queries
  getLocation(accountId: String!, locationId: String!): LocationResult
  listLocations(accountId: String!, options: ListLocationsInput): LocationListResult!
}

type Mutation {
  # Unit mutations
  createUnit(input: CreateUnitInput!): Unit!
  updateUnit(input: UpdateUnitInput!): Unit!
  deleteUnit(id: ID!, accountId: String!): Boolean!
  
  # Location mutations
  createAddressLocation(input: CreateAddressLocationInput!): String!
  createCoordinatesLocation(input: CreateCoordinatesLocationInput!): String!
  updateAddressLocation(locationId: String!, input: UpdateAddressLocationInput!): Boolean!
  updateCoordinatesLocation(locationId: String!, input: UpdateCoordinatesLocationInput!): Boolean!
  deleteLocation(accountId: String!, locationId: String!): Boolean!
}